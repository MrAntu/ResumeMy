# iOS进阶

## 1.建立自己的开发知识体系
![ios知识体系图.png](https://upload-images.jianshu.io/upload_images/2026287-3951f5c8983ee6b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 
 
## 2.App 启动速度怎么做优化与监控
一般情况下分为冷启动和热启动
* 冷启动： App点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。
* 热启动： App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。
所以，在开发中，只需要解决冷启动的问题

#### 1.app在启动时都做了哪些事情
1.main() 函数执行前；
2.main() 函数执行后;
3.首屏渲染完成后;

##### main()函数执行前
* 加载可执行文件（app的.o文件的集合）
* 加载动态链接库, 进行rebase指针调整和bind符号绑定
* Objc运行时的初始处理，包括Objc相关类的注册，category注册，selector唯一性检查等
* 初始化，包括了执行+load（）方法，constructor修饰的函数的调用，创建c++静态全局变量

相应地，这个阶段对于启动速度优化来说，可以做的事情有：
* 减少动态库加载，每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并，数量上，苹果公司最多可以支持6个非系统动态库合并为一个
* 减少加载启动后不会去使用的类或者方法
* +load（）方法里的内容可以放到首屏渲染完成后再执行。或使用+initialize（）方法替换掉。因为，一个+load（）方法，进行运行时方法替换操作会带来4毫秒的消耗，积少成多。
* 控制C++全局变量的数量

#### main()函数执行后
指的是从main（）函数执行开始，到appDelegate的didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。

首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括:
* 首屏初始化所需配置文件的读写操作
* 首屏列表大数据的读取
* 首屏渲染的大量计算

更加优化的开发方式，应该是从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是app启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的，梳理完后，将这些初始化功能分别放到合适的阶段进行

#### 首屏渲染完成后
非首屏其他业务服务模块的初始化，监听的注册，配置文件的读取等，这个阶段用户已经能够看到app的首页信息，所以优化级别排在最后，但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作，、

#### 功能级别的启动优化
是从main（）函数执行后这个阶段下手
优化思路： mian（）函数开始执行后到首屏渲染完成前只处理首屏相关的业务。其他非首屏业务的初始化，监听注册，配置文件读取等都放到首屏渲染完成后去做：
![f30f438d447e81132dd520e657427419.png](https://upload-images.jianshu.io/upload_images/2026287-4db7b138db4aa386.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 方法级别的启动优化
检查首屏渲染完成前主线程有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通过情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载，编辑，存储图片和文件等资源。
**是不是只需要优化对资源的操作就可以了？**
当然不是，就像+load（）方法，一个耗时4ms，100个就是400ms，这种耗时用户也是能明显感知的。
比如RAC框架，创建一个信号有6ms的耗时，这样，稍不注意各种信号的创建就都被放在首屏渲染完成前，进而导致app的启动速度大幅度变慢。

目前。对App启动速度的监控，主要有两种手段：
* Time Profiler -- 时间间隔设置的长，会漏掉一些方法，从而导致检查出来的耗时不精确，而定时间隔设置的短了，抓取堆栈这个方法本身调用过多会影响整体耗时，导致结果不准确。 一般设置为0.01s。
* 对objc_msgSend方法进行hook来掌握所有方法的执行耗时，

使用计时对一段代码进行耗时统计
```
let startTime = CFAbsoluteTimeGetCurrent()
let endTime = CFAbsoluteTimeGetCurrent()
debugPrint("代码执行时长：%f 毫秒", (endTime - startTime)*1000)
```

